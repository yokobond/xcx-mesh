var img$2 = "data:image/png;base64,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";

var img$1 = "data:image/svg+xml,%3c%3fxml version='1.0' encoding='UTF-8' standalone='no'%3f%3e%3c!-- Created with Inkscape (http://www.inkscape.org/) --%3e%3csvg version='1.1' id='svg1' width='53' height='53' viewBox='0 0 53 53' xmlns='http://www.w3.org/2000/svg' xmlns:svg='http://www.w3.org/2000/svg'%3e %3cdefs id='defs1' /%3e %3cg id='g137' transform='matrix(0.48801155%2c0%2c0%2c0.48801155%2c-95.157399%2c-126.30004)' style='display:inline'%3e %3cg id='g124' transform='matrix(0.38185617%2c0%2c0%2c0.38185617%2c56.483232%2c161.13878)' style='display:inline'%3e %3cpath id='path124' style='fill:%2391d5ff%3bfill-opacity:1%3bstroke:%234a90e2%3bstroke-width:10.4751' d='M 435.09909%2c505.99384 392.99487%2c372.54462 506.90359%2c291.26346 619.40625%2c374.47675 575.02924%2c507.1868 Z' /%3e %3c/g%3e %3cg id='g138' style='stroke-width:6.1474%3bstroke-dasharray:none'%3e %3cline x1='293.00204' y1='304.32098' x2='276.0564' y2='354.99713' id='line124' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='293.00204' y1='304.32098' x2='222.62321' y2='354.5416' id='line125' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='293.00204' y1='304.32098' x2='206.54546' y2='303.58319' id='line126' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='293.00204' y1='304.32098' x2='250.04221' y2='272.54547' id='line127' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='276.0564' y1='354.99713' x2='222.62321' y2='354.5416' id='line128' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='276.0564' y1='354.99713' x2='206.54546' y2='303.58319' id='line129' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='276.0564' y1='354.99713' x2='250.04221' y2='272.54547' id='line130' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='222.62321' y1='354.5416' x2='206.54546' y2='303.58319' id='line131' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='222.62321' y1='354.5416' x2='250.04221' y2='272.54547' id='line132' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cline x1='206.54546' y1='303.58319' x2='250.04221' y2='272.54547' id='line133' style='fill:none%3bstroke:%23e1edfa%3bstroke-width:8.22726%3bstroke-dasharray:none%3bstroke-opacity:1' /%3e %3cpath id='circle133' style='fill:%234a90e2%3bstroke:%23e1edfa%3bstroke-width:4.15359%3bstroke-dasharray:none%3bstroke-opacity:1' transform='rotate(-17.51091)' d='m 195.85789%2c378.37927 a 8%2c8 0 0 1 -8%2c8 8%2c8 0 0 1 -8%2c-8 8%2c8 0 0 1 8%2c-8 8%2c8 0 0 1 8%2c8 z' /%3e %3cpath id='circle134' style='fill:%234a90e2%3bstroke:%23e1edfa%3bstroke-width:4.15359%3bstroke-dasharray:none%3bstroke-opacity:1' transform='rotate(-17.51091)' d='m 164.44971%2c421.60837 a 8%2c8 0 0 1 -8%2c8 8%2c8 0 0 1 -8%2c-8 8%2c8 0 0 1 8%2c-8 8%2c8 0 0 1 8%2c8 z' /%3e %3cpath id='circle135' style='fill:%234a90e2%3bstroke:%23e1edfa%3bstroke-width:4.15359%3bstroke-dasharray:none%3bstroke-opacity:1' transform='rotate(-17.51091)' d='m 113.62971%2c405.09659 a 8%2c8 0 0 1 -8%2c8 8%2c8 0 0 1 -8.000003%2c-8 8%2c8 0 0 1 8.000003%2c-8 8%2c8 0 0 1 8%2c8 z' /%3e %3cpath id='circle136' style='fill:%234a90e2%3bstroke:%23e1edfa%3bstroke-width:4.15359%3bstroke-dasharray:none%3bstroke-opacity:1' transform='rotate(-17.51091)' d='m 113.62971%2c351.66202 a 8%2c8 0 0 1 -8%2c8 8%2c8 0 0 1 -8.000003%2c-8 8%2c8 0 0 1 8.000003%2c-8 8%2c8 0 0 1 8%2c8 z' /%3e %3cpath id='circle137' style='fill:%234a90e2%3bstroke:%23e1edfa%3bstroke-width:4.15359%3bstroke-dasharray:none%3bstroke-opacity:1' transform='rotate(-17.51091)' d='m 164.44971%2c335.15018 a 8%2c8 0 0 1 -8%2c8 8%2c8 0 0 1 -8%2c-8 8%2c8 0 0 1 8%2c-8 8%2c8 0 0 1 8%2c8 z' /%3e %3c/g%3e %3cg id='g151' style='display:inline'%3e %3cline x1='293.00204' y1='304.32098' x2='276.0564' y2='354.99713' id='line138' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='293.00204' y1='304.32098' x2='222.62321' y2='354.5416' id='line139' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='293.00204' y1='304.32098' x2='206.54546' y2='303.58319' id='line140' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='293.00204' y1='304.32098' x2='250.04221' y2='272.54547' id='line141' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='276.0564' y1='354.99713' x2='222.62321' y2='354.5416' id='line142' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='276.0564' y1='354.99713' x2='206.54546' y2='303.58319' id='line143' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='276.0564' y1='354.99713' x2='250.04221' y2='272.54547' id='line144' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='222.62321' y1='354.5416' x2='206.54546' y2='303.58319' id='line145' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='222.62321' y1='354.5416' x2='250.04221' y2='272.54547' id='line146' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3cline x1='206.54546' y1='303.58319' x2='250.04221' y2='272.54547' id='line147' style='fill:none%3bstroke:%234a90e2%3bstroke-width:4%3bstroke-dasharray:none' /%3e %3ccircle cx='187.85789' cy='378.37927' fill='%234a90e2' id='circle147' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='156.44971' cy='421.60837' fill='%234a90e2' id='circle148' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='105.62971' cy='405.09659' fill='%234a90e2' id='circle149' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='105.62971' cy='351.66202' fill='%234a90e2' id='circle150' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3ccircle cx='156.44971' cy='335.15018' fill='%234a90e2' id='circle151' transform='rotate(-17.51091)' style='stroke-width:0.909%3bstroke-dasharray:none' r='8' /%3e %3c/g%3e %3c/g%3e%3c/svg%3e";

var en$1 = {
	"xcxMesh.entry.name": "Mesh",
	"xcxMesh.entry.description": "A block for peer-to-peer communication. It establishes a data channel using WebRTC and sends and receives data."
};
var ja$1 = {
	"xcxMesh.entry.name": "Mesh",
	"xcxMesh.entry.description": "ピアツーピアの通信を行う。WebRTCを利用して、データチャンネルを確立し、データの送受信をする。"
};
var translations$1 = {
	en: en$1,
	ja: ja$1,
	"ja-Hira": {
	"xcxMesh.entry.name": "メッシュ",
	"xcxMesh.entry.description": "1 たい 1 の つうしん を おこなう。"
}
};

/**
 * This is an extension for Xcratch.
 */


/**
 * Formatter to translate the messages in this extension.
 * This will be replaced which is used in the React component.
 * @param {object} messageData - data for format-message
 * @returns {string} - translated message for the current locale
 */
var formatMessage$1 = function formatMessage(messageData) {
  return messageData.defaultMessage;
};
var entry = {
  get name() {
    return formatMessage$1({
      id: 'xcxMesh.entry.name',
      defaultMessage: 'Mesh',
      description: 'name of the extension'
    });
  },
  extensionId: 'xcxMesh',
  extensionURL: 'https://yokobond.github.io/xcx-mesh/dist/xcxMesh.mjs',
  collaborator: 'yokobond',
  iconURL: img$2,
  insetIconURL: img$1,
  get description() {
    return formatMessage$1({
      defaultMessage: 'Mesh extension for Xcratch',
      id: 'xcxMesh.entry.description'
    });
  },
  featured: true,
  disabled: false,
  bluetoothRequired: false,
  internetConnectionRequired: true,
  helpLink: 'https://yokobond.github.io/xcx-mesh/',
  setFormatMessage: function setFormatMessage(formatter) {
    formatMessage$1 = formatter;
  },
  translationMap: translations$1
};

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

function _classCallCheck$1(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _typeof$2(o) {
  "@babel/helpers - typeof";

  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$2(o);
}

function toPrimitive$1(t, r) {
  if ("object" != _typeof$2(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof$2(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}

function toPropertyKey$1(t) {
  var i = toPrimitive$1(t, "string");
  return "symbol" == _typeof$2(i) ? i : i + "";
}

function _defineProperties$1(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey$1(o.key), o);
  }
}
function _createClass$1(e, r, t) {
  return r && _defineProperties$1(e.prototype, r), t && _defineProperties$1(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var regeneratorRuntime$1 = {exports: {}};

var _typeof$1 = {exports: {}};

(function (module) {
  function _typeof(o) {
    "@babel/helpers - typeof";

    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$1);
var _typeofExports = _typeof$1.exports;

(function (module) {
  var _typeof = _typeofExports["default"];
  function _regeneratorRuntime() {

    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
      return e;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function define(t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function value(t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(_typeof(e) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function stop() {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function complete(t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function finish(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      "catch": function _catch(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

// TODO(Babel 8): Remove this file.

var runtime = regeneratorRuntimeExports();
var regenerator = runtime;

// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof$2(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
var _regeneratorRuntime = /*@__PURE__*/getDefaultExportFromCjs(regenerator);

/**
 * Types of block
 * @enum {string}
 */
var BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',
  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',
  /**
   * Command block
   */
  COMMAND: 'command',
  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',
  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',
  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',
  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',
  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
var blockType = BlockType;
var BlockType$1 = /*@__PURE__*/getDefaultExportFromCjs(blockType);

/**
 * Block argument types
 * @enum {string}
 */
var ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',
  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',
  /**
   * Numeric value with color picker
   */
  COLOR: 'color',
  /**
   * Numeric value with text field
   */
  NUMBER: 'number',
  /**
   * String value with text field
   */
  STRING: 'string',
  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',
  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',
  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
var argumentType = ArgumentType;
var ArgumentType$1 = /*@__PURE__*/getDefaultExportFromCjs(argumentType);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}

function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var Color$1 = /*#__PURE__*/function () {
  function Color() {
    _classCallCheck(this, Color);
  }
  return _createClass(Color, null, [{
    key: "RGB_BLACK",
    get:
    /**
     * @typedef {object} RGBObject - An object representing a color in RGB format.
     * @property {number} r - the red component, in the range [0, 255].
     * @property {number} g - the green component, in the range [0, 255].
     * @property {number} b - the blue component, in the range [0, 255].
     */

    /**
     * @typedef {object} HSVObject - An object representing a color in HSV format.
     * @property {number} h - hue, in the range [0-359).
     * @property {number} s - saturation, in the range [0,1].
     * @property {number} v - value, in the range [0,1].
     */

    /** @type {RGBObject} */
    function get() {
      return {
        r: 0,
        g: 0,
        b: 0
      };
    }

    /** @type {RGBObject} */
  }, {
    key: "RGB_WHITE",
    get: function get() {
      return {
        r: 255,
        g: 255,
        b: 255
      };
    }

    /**
     * Convert a Scratch decimal color to a hex string, #RRGGBB.
     * @param {number} decimal RGB color as a decimal.
     * @return {string} RGB color as #RRGGBB hex string.
     */
  }, {
    key: "decimalToHex",
    value: function decimalToHex(decimal) {
      if (decimal < 0) {
        decimal += 0xFFFFFF + 1;
      }
      var hex = Number(decimal).toString(16);
      hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
      return hex;
    }

    /**
     * Convert a Scratch decimal color to an RGB color object.
     * @param {number} decimal RGB color as decimal.
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "decimalToRgb",
    value: function decimalToRgb(decimal) {
      var a = decimal >> 24 & 0xFF;
      var r = decimal >> 16 & 0xFF;
      var g = decimal >> 8 & 0xFF;
      var b = decimal & 0xFF;
      return {
        r: r,
        g: g,
        b: b,
        a: a > 0 ? a : 255
      };
    }

    /**
     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
     * CC-BY-SA Tim Down:
     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param {!string} hex Hex representation of the color.
     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hexToRgb",
    value: function hexToRgb(hex) {
      var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
      });
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    /**
     * Convert an RGB color object to a hex color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!string} Hex representation of the color.
     */
  }, {
    key: "rgbToHex",
    value: function rgbToHex(rgb) {
      return Color.decimalToHex(Color.rgbToDecimal(rgb));
    }

    /**
     * Convert an RGB color object to a Scratch decimal color.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {!number} Number representing the color.
     */
  }, {
    key: "rgbToDecimal",
    value: function rgbToDecimal(rgb) {
      return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
    }

    /**
    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
    * @param {!string} hex Hex representation of the color.
    * @return {!number} Number representing the color.
    */
  }, {
    key: "hexToDecimal",
    value: function hexToDecimal(hex) {
      return Color.rgbToDecimal(Color.hexToRgb(hex));
    }

    /**
     * Convert an HSV color to RGB format.
     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     */
  }, {
    key: "hsvToRgb",
    value: function hsvToRgb(hsv) {
      var h = hsv.h % 360;
      if (h < 0) h += 360;
      var s = Math.max(0, Math.min(hsv.s, 1));
      var v = Math.max(0, Math.min(hsv.v, 1));
      var i = Math.floor(h / 60);
      var f = h / 60 - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      return {
        r: Math.floor(r * 255),
        g: Math.floor(g * 255),
        b: Math.floor(b * 255)
      };
    }

    /**
     * Convert an RGB color to HSV format.
     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
     */
  }, {
    key: "rgbToHsv",
    value: function rgbToHsv(rgb) {
      var r = rgb.r / 255;
      var g = rgb.g / 255;
      var b = rgb.b / 255;
      var x = Math.min(Math.min(r, g), b);
      var v = Math.max(Math.max(r, g), b);

      // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate
      var h = 0;
      var s = 0;
      if (x !== v) {
        var f = r === x ? g - b : g === x ? b - r : r - g;
        var i = r === x ? 3 : g === x ? 5 : 1;
        h = (i - f / (v - x)) * 60 % 360;
        s = (v - x) / v;
      }
      return {
        h: h,
        s: s,
        v: v
      };
    }

    /**
     * Linear interpolation between rgb0 and rgb1.
     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
     * @return {RGBObject} the interpolated color.
     */
  }, {
    key: "mixRgb",
    value: function mixRgb(rgb0, rgb1, fraction1) {
      if (fraction1 <= 0) return rgb0;
      if (fraction1 >= 1) return rgb1;
      var fraction0 = 1 - fraction1;
      return {
        r: fraction0 * rgb0.r + fraction1 * rgb1.r,
        g: fraction0 * rgb0.g + fraction1 * rgb1.g,
        b: fraction0 * rgb0.b + fraction1 * rgb1.b
      };
    }
  }]);
}();
var color = Color$1;

var Color = color;

/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */
var Cast = /*#__PURE__*/function () {
  function Cast() {
    _classCallCheck(this, Cast);
  }
  return _createClass(Cast, null, [{
    key: "toNumber",
    value:
    /**
     * Scratch cast to number.
     * Treats NaN as 0.
     * In Scratch 2.0, this is captured by `interp.numArg.`
     * @param {*} value Value to cast to number.
     * @return {number} The Scratch-casted number value.
     */
    function toNumber(value) {
      // If value is already a number we don't need to coerce it with
      // Number().
      if (typeof value === 'number') {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        if (Number.isNaN(value)) {
          return 0;
        }
        return value;
      }
      if (typeof value === 'string') {
        // Replace full-width numbers with half-width ones.
        value = value.replace(/[０-９＋．ｅ]/g, function (s) {
          return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
        });
        value = value.replace(/[-－﹣−‐⁃‑‒–—﹘―⎯⏤ーｰ─━]/g, '-');
      }
      var n = Number(value);
      if (Number.isNaN(n)) {
        // Scratch treats NaN as 0, when needed as a number.
        // E.g., 0 + NaN -> 0.
        return 0;
      }
      return n;
    }

    /**
     * Scratch cast to boolean.
     * In Scratch 2.0, this is captured by `interp.boolArg.`
     * Treats some string values differently from JavaScript.
     * @param {*} value Value to cast to boolean.
     * @return {boolean} The Scratch-casted boolean value.
     */
  }, {
    key: "toBoolean",
    value: function toBoolean(value) {
      // Already a boolean?
      if (typeof value === 'boolean') {
        return value;
      }
      if (typeof value === 'string') {
        // These specific strings are treated as false in Scratch.
        if (value === '' || value === '0' || value.toLowerCase() === 'false') {
          return false;
        }
        // All other strings treated as true.
        return true;
      }
      // Coerce other values and numbers.
      return Boolean(value);
    }

    /**
     * Scratch cast to string.
     * @param {*} value Value to cast to string.
     * @return {string} The Scratch-casted string value.
     */
  }, {
    key: "toString",
    value: function toString(value) {
      return String(value).replace(/\\n/g, '\n').replace(/\\t/g, '\t');
    }

    /**
     * Cast any Scratch argument to an RGB color array to be used for the renderer.
     * @param {*} value Value to convert to RGB color array.
     * @return {Array.<number>} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorList",
    value: function toRgbColorList(value) {
      var color = Cast.toRgbColorObject(value);
      return [color.r, color.g, color.b];
    }

    /**
     * Cast any Scratch argument to an RGB color object to be used for the renderer.
     * @param {*} value Value to convert to RGB color object.
     * @return {RGBOject} [r,g,b], values between 0-255.
     */
  }, {
    key: "toRgbColorObject",
    value: function toRgbColorObject(value) {
      var color;
      if (typeof value === 'string' && value.substring(0, 1) === '#') {
        color = Color.hexToRgb(value);

        // If the color wasn't *actually* a hex color, cast to black
        if (!color) color = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
      } else {
        color = Color.decimalToRgb(Cast.toNumber(value));
      }
      return color;
    }

    /**
     * Determine if a Scratch argument is a white space string (or null / empty).
     * @param {*} val value to check.
     * @return {boolean} True if the argument is all white spaces or null / empty.
     */
  }, {
    key: "isWhiteSpace",
    value: function isWhiteSpace(val) {
      return val === null || typeof val === 'string' && val.trim().length === 0;
    }

    /**
     * Compare two values, using Scratch cast, case-insensitive string compare, etc.
     * In Scratch 2.0, this is captured by `interp.compare.`
     * @param {*} v1 First value to compare.
     * @param {*} v2 Second value to compare.
     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
     */
  }, {
    key: "compare",
    value: function compare(v1, v2) {
      var n1 = Number(v1);
      var n2 = Number(v2);
      if (n1 === 0 && Cast.isWhiteSpace(v1)) {
        n1 = NaN;
      } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
        n2 = NaN;
      }
      if (isNaN(n1) || isNaN(n2)) {
        // At least one argument can't be converted to a number.
        // Scratch compares strings as case insensitive.
        var s1 = Cast.toString(v1).toLowerCase();
        var s2 = Cast.toString(v2).toLowerCase();
        if (s1 < s2) {
          return -1;
        } else if (s1 > s2) {
          return 1;
        }
        return 0;
      }
      // Handle the special case of Infinity
      if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
        return 0;
      }
      // Compare as numbers.
      return n1 - n2;
    }

    /**
     * Determine if a Scratch argument number represents a round integer.
     * @param {*} val Value to check.
     * @return {boolean} True if number looks like an integer.
     */
  }, {
    key: "isInt",
    value: function isInt(val) {
      // Values that are already numbers.
      if (typeof val === 'number') {
        if (isNaN(val)) {
          // NaN is considered an integer.
          return true;
        }
        // True if it's "round" (e.g., 2.0 and 2).
        return val === parseInt(val, 10);
      } else if (typeof val === 'boolean') {
        // `True` and `false` always represent integer after Scratch cast.
        return true;
      } else if (typeof val === 'string') {
        // If it contains a decimal point, don't consider it an int.
        return val.indexOf('.') < 0;
      }
      return false;
    }
  }, {
    key: "LIST_INVALID",
    get: function get() {
      return 'INVALID';
    }
  }, {
    key: "LIST_ALL",
    get: function get() {
      return 'ALL';
    }

    /**
     * Compute a 1-based index into a list, based on a Scratch argument.
     * Two special cases may be returned:
     * LIST_ALL: if the block is referring to all of the items in the list.
     * LIST_INVALID: if the index was invalid in any way.
     * @param {*} index Scratch arg, including 1-based numbers or special cases.
     * @param {number} length Length of the list.
     * @param {boolean} acceptAll Whether it should accept "all" or not.
     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
     */
  }, {
    key: "toListIndex",
    value: function toListIndex(index, length, acceptAll) {
      if (typeof index !== 'number') {
        if (index === 'all') {
          return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
        }
        if (index === 'last') {
          if (length > 0) {
            return length;
          }
          return Cast.LIST_INVALID;
        } else if (index === 'random' || index === 'any') {
          if (length > 0) {
            return 1 + Math.floor(Math.random() * length);
          }
          return Cast.LIST_INVALID;
        }
      }
      index = Math.floor(Cast.toNumber(index));
      if (index < 1 || index > length) {
        return Cast.LIST_INVALID;
      }
      return index;
    }
  }]);
}();
var cast = Cast;
var Cast$1 = /*@__PURE__*/getDefaultExportFromCjs(cast);

var en = {
	"xcxMesh.name": "Mesh",
	"xcxMesh.openPeer": "open peer [ID]",
	"xcxMesh.openPeer.defaultID": "myID",
	"xcxMesh.myID": "my ID",
	"xcxMesh.isPeerOpen": "peer is open",
	"xcxMesh.closePeer": "close peer",
	"xcxMesh.setPeerServer": "set peer server to [SERVER]",
	"xcxMesh.setICEServers": "set ICE servers to [SERVERS]",
	"xcxMesh.openDataConnection": "open connection to [ID]",
	"xcxMesh.openDataConnection.defaultID": "remoteID",
	"xcxMesh.isDataConnectionOpen": "connection to [ID] is open",
	"xcxMesh.isDataConnectionOpen.defaultID": "remoteID",
	"xcxMesh.closeDataConnection": "close connection to [ID]",
	"xcxMesh.closeDataConnection.defaultID": "remoteID",
	"xcxMesh.whenDataConnectionRequested": "when connection requested",
	"xcxMesh.dataConnectionIDAt": "connection ID at [CONNECTION_INDEX]",
	"xcxMesh.dataConnectionCount": "connection count",
	"xcxMesh.setSharedVar": "set value of [KEY] to [VALUE]",
	"xcxMesh.setSharedVar.defaultKey": "key",
	"xcxMesh.setSharedVar.defaultValue": "value",
	"xcxMesh.sharedVar": "value of [KEY]",
	"xcxMesh.sharedVar.defaultKey": "key",
	"xcxMesh.dispatchSharedEvent": "dispatch event [TYPE] with [DATA]",
	"xcxMesh.dispatchSharedEvent.defaultEvent": "event",
	"xcxMesh.dispatchSharedEvent.defaultData": "data",
	"xcxMesh.whenSharedEventReceived": "when event received",
	"xcxMesh.lastSharedEventType": "event type",
	"xcxMesh.lastSharedEventData": "event data"
};
var ja = {
	"xcxMesh.name": "Mesh",
	"xcxMesh.openPeer": "ピア [ID] を開く",
	"xcxMesh.openPeer.defaultID": "myID",
	"xcxMesh.myID": "自分のID",
	"xcxMesh.isPeerOpen": "ピアが開いている",
	"xcxMesh.closePeer": "ピアを閉じる",
	"xcxMesh.setPeerServer": "ピアサーバーを [SERVER] にする",
	"xcxMesh.setICEServers": "ICEサーバーを [SERVERS] にする",
	"xcxMesh.openDataConnection": "[ID] と接続する",
	"xcxMesh.openDataConnection.defaultID": "remoteID",
	"xcxMesh.isDataConnectionOpen": "[ID] と接続している",
	"xcxMesh.isDataConnectionOpen.defaultID": "remoteID",
	"xcxMesh.closeDataConnection": "[ID] を切断する",
	"xcxMesh.closeDataConnection.defaultID": "remoteID",
	"xcxMesh.whenDataConnectionRequested": "接続が要求されたとき",
	"xcxMesh.dataConnectionIDAt": "[CONNECTION_INDEX] 番目の接続ID",
	"xcxMesh.dataConnectionCount": "接続数",
	"xcxMesh.setSharedVar": "[KEY] を [VALUE] にする",
	"xcxMesh.setSharedVar.defaultKey": "key",
	"xcxMesh.setSharedVar.defaultValue": "value",
	"xcxMesh.sharedVar": "[KEY] の値",
	"xcxMesh.sharedVar.defaultKey": "key",
	"xcxMesh.dispatchSharedEvent": "[TYPE] イベントを [DATA] と共に送る",
	"xcxMesh.dispatchSharedEvent.defaultEvent": "event",
	"xcxMesh.dispatchSharedEvent.defaultData": "data",
	"xcxMesh.whenSharedEventReceived": "イベントを受け取ったとき",
	"xcxMesh.lastSharedEventType": "イベントのタイプ",
	"xcxMesh.lastSharedEventData": "イベントのデータ"
};
var translations = {
	en: en,
	ja: ja,
	"ja-Hira": {
	"xcxMesh.name": "メッシュ",
	"xcxMesh.openPeer": "ピア [ID] を ひらく",
	"xcxMesh.openPeer.defaultID": "myID",
	"xcxMesh.myID": "じぶんのID",
	"xcxMesh.isPeerOpen": "ピア が ひらいている",
	"xcxMesh.closePeer": "ピア を とじる",
	"xcxMesh.setPeerServer": "ピアサーバー を [SERVER] に する",
	"xcxMesh.setICEServers": "ICEサーバー を [SERVERS] に する",
	"xcxMesh.openDataConnection": "[ID] と せつぞく する",
	"xcxMesh.openDataConnection.defaultID": "remoteID",
	"xcxMesh.isDataConnectionOpen": "[ID] と せつぞく している",
	"xcxMesh.isDataConnectionOpen.defaultID": "remoteID",
	"xcxMesh.closeDataConnection": "[ID] と せつだん する",
	"xcxMesh.closeDataConnection.defaultID": "remoteID",
	"xcxMesh.whenDataConnectionRequested": "せつぞく が ようきゅうされた とき",
	"xcxMesh.dataConnectionIDAt": "[CONNECTION_INDEX] ばんめ の せつぞくID",
	"xcxMesh.dataConnectionCount": "せつぞくのかず",
	"xcxMesh.setSharedVar": "[KEY] を [VALUE] に する",
	"xcxMesh.setSharedVar.defaultKey": "key",
	"xcxMesh.setSharedVar.defaultValue": "value",
	"xcxMesh.sharedVar": "[KEY] の あたい",
	"xcxMesh.sharedVar.defaultKey": "key",
	"xcxMesh.dispatchSharedEvent": "[TYPE] イベント を [DATA] と ともに おくる",
	"xcxMesh.dispatchSharedEvent.defaultEvent": "event",
	"xcxMesh.dispatchSharedEvent.defaultData": "data",
	"xcxMesh.whenSharedEventReceived": "イベント を うけとった とき",
	"xcxMesh.lastSharedEventType": "イベント の タイプ",
	"xcxMesh.lastSharedEventData": "イベント の データ"
}
};

var img = "data:image/png;base64,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";

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _arrayLikeToArray$1(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _unsupportedIterableToArray$1(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest();
}

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
/** @type {any} Peer from PeerJS library */
var Peer;
_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
  var _yield$import;
  return _regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) switch (_context.prev = _context.next) {
      case 0:
        _context.next = 2;
        return import(/* webpackIgnore: true */
        'https://cdn.jsdelivr.net/npm/peerjs@1.5.4/+esm');
      case 2:
        _yield$import = _context.sent;
        Peer = _yield$import.Peer;
      case 4:
      case "end":
        return _context.stop();
    }
  }, _callee);
}))();

/**
 * Encode a Mesh ID to a PeerJS ID
 * @param {string} meshID - Mesh ID
 * @returns {string} PeerJS ID
 */
var encodeToPeerID = function encodeToPeerID(meshID) {
  return "0".concat(btoa(encodeURIComponent(meshID)), "0").replace(/[=]/g, '0equal0');
};

/**
 * Decode a PeerJS ID to a Mesh ID
 * @param {string} peerID - PeerJS ID
 * @returns {string} Mesh ID
 */
var decodeFromPeerID = function decodeFromPeerID(peerID) {
  return decodeURIComponent(atob(peerID.slice(1, -1).replace(/0equal0/g, '=')));
};

/**
 * Class representing a mesh network of peer connections
 */
var Mesh = /*#__PURE__*/function () {
  /**
   * Create a Mesh instance
   */
  function Mesh() {
    _classCallCheck$1(this, Mesh);
    /** @type {Peer|null} PeerJS instance */
    this.peer = null;
    /** @type {string|null} PeerJS server host */
    this.peerServer = null;
    /** @type {string} ICE servers configuration */
    this.iceServers = null;
    /** @type {string|null} Local peer ID */
    this.id = null;
    /** @type {Map<string, DataConnection>} Map of peer connections */
    this.connections = new Map();
    /** @type {Array<Function>} Event listener callback */
    this.eventListeners = [];
    /** @type {Map<string, any>} Map of shared variables */
    this.sharedVars = new Map();
    /** @type {Array<{sender: string, time: number, type: string, data: any}>} Shared event buffer */
    this.sharedEventBuffer = [];
    /** @type {number} Length of the shared event buffer */
    this.sharedEventBufferLength = 10;
    /** @type {number} Index of the last shared event processed */
    this.sharedEventIndex = 0;
  }

  /**
   * Add a listener for Mesh events
   * @param {Function} listener - Callback function for events
   * @returns {void}
   */
  return _createClass$1(Mesh, [{
    key: "addMeshEventListener",
    value: function addMeshEventListener(listener) {
      this.eventListeners.push(listener);
    }

    /**
     * Remove a listener for Mesh events
     * @param {Function} listener - Callback function for events
     * @returns {void}
     */
  }, {
    key: "removeMeshEventListener",
    value: function removeMeshEventListener(listener) {
      var index = this.eventListeners.indexOf(listener);
      if (index > -1) {
        this.eventListeners.splice(index, 1);
      }
    }

    /**
     * Set PeerJS server host
     * @param {string} server - PeerJS server host
     */
  }, {
    key: "setPeerServer",
    value: function setPeerServer(server) {
      this.peerServer = server;
    }

    /**
     * Set ICE servers configuration
     * @param {string} servers - ICE servers configuration in JSON format
     */
  }, {
    key: "setICEServers",
    value: function setICEServers(servers) {
      if (servers.charAt(0) !== '[') {
        servers = "[".concat(servers, "]");
      }
      var serversData = JSON.parse(servers);
      this.ICEServers = serversData;
    }

    /**
     * Open a peer connection.
     * If the connection is already open with the same ID, return the existing instance.
     * @param {string} localID - Local Mesh ID
     * @returns {Promise<Peer>} Promise that resolves with the PeerJS instance
     */
  }, {
    key: "openPeer",
    value: function openPeer(localID) {
      var _this = this;
      if (localID === '') {
        localID = "mesh-".concat(Math.random().toString(36).substring(2, 6));
      }
      if (this.peer) {
        if (this.id === localID && !this.peer.disconnected) {
          return Promise.resolve(this.peer);
        }
        this.closePeer();
      }
      return new Promise(function (resolve, reject) {
        var options = {
          config: {
            iceServers: _this.iceServers ? _this.iceServers : []
          }
        };
        if (_this.peerServer) {
          var url = new URL(_this.peerServer);
          options.host = url.hostname;
          options.port = url.port || (url.protocol === 'https:' ? 443 : 80);
          options.path = url.pathname;
          if (options.path.endsWith('/')) {
            options.path = options.path.slice(0, -1);
          }
          options.secure = url.protocol === 'https:';
        }
        _this.peer = new Peer(encodeToPeerID(localID), options);
        _this.peer.on('open', function (peerID) {
          _this.id = decodeFromPeerID(peerID);
          _this.peer.on('connection', function (requested) {
            var remoteID = decodeFromPeerID(requested.peer);
            requested.on('open', function () {
              var _onSyncAnswer = function onSyncAnswer(data) {
                if (data.type === 'control' && data.command === 'syncAnswer') {
                  data.vars.forEach(function (_ref2) {
                    var _ref3 = _slicedToArray(_ref2, 2),
                      key = _ref3[0],
                      value = _ref3[1];
                    _this.setSharedVar(key, value);
                  });
                  requested.off('data', _onSyncAnswer);
                  _this._setupDataConnection(requested, remoteID);
                  _this._registerDataConnection(requested, remoteID);
                  _this.eventListeners.forEach(function (listener) {
                    listener({
                      type: 'dataConnectionRequested',
                      data: remoteID
                    });
                  });
                }
              };
              requested.on('data', _onSyncAnswer);
              var syncRequest = {
                sender: _this.id,
                time: Date.now(),
                type: 'control',
                command: 'syncRequest',
                vars: Array.from(_this.sharedVars)
              };
              requested.send(syncRequest);
            });
          });
          resolve(_this.peer);
        });
        _this.peer.on('error', function (err) {
          _this.closePeer();
          reject(err);
        });
      });
    }

    /**
     * Close the peer connection and all data channels
     */
  }, {
    key: "closePeer",
    value: function closePeer() {
      // Close all data channels first
      var _iterator = _createForOfIteratorHelper(this.connections.values()),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var connection = _step.value;
          connection.close();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      this.connections.clear();

      // Destroy the peer connection
      if (this.peer) {
        this.peer.destroy();
        this.peer = null;
        this.id = null;
      }
    }

    /**
     * Check if the peer connection is open
     * @returns {boolean} True if the peer connection is open
     */
  }, {
    key: "isPeerOpen",
    value: function isPeerOpen() {
      return !!this.peer && !this.peer.disconnected;
    }

    /**
     * Setup a data connection
     * @param {DataConnection} connection - PeerJS DataConnection instance
     * @param {string} remoteID - Remote Mesh ID
     */
  }, {
    key: "_setupDataConnection",
    value: function _setupDataConnection(connection, remoteID) {
      var _this2 = this;
      connection.on('data', function (data) {
        if (data.type === 'var') {
          if (_this2.sharedVars.get(data.key) !== data.value) {
            _this2.connections.forEach(function (conn) {
              if (conn !== connection) {
                conn.send(data);
              }
            });
            _this2.sharedVars.set(data.key, data.value);
          }
        } else if (data.type === 'event') {
          if (data.sender === _this2.id) return;
          var received = _this2.sharedEventBuffer.length > 0 && _this2.sharedEventBuffer.every(function (event) {
            return event.sender === data.sender && event.time === data.time && event.type === data.type && event.eventType === data.eventType && event.eventData === data.eventData;
          });
          if (!received) {
            _this2.connections.forEach(function (conn) {
              if (conn !== connection) {
                conn.send(data);
              }
            });
            _this2.onSharedEvent(data);
          }
        }
      });
      connection.on('close', function () {
        _this2.eventListeners.forEach(function (listener) {
          listener({
            type: 'dataConnectionClosed',
            data: remoteID
          });
        });
      });
      connection.on('error', function (err) {
        _this2.eventListeners.forEach(function (listener) {
          listener({
            type: 'dataConnectionError',
            data: remoteID,
            error: err
          });
        });
      });
    }

    /**
     * Register a data connection
     * @param {DataConnection} connection - PeerJS DataConnection instance
     * @param {string} remoteID - Remote Mesh ID
     * @private
     */
  }, {
    key: "_registerDataConnection",
    value: function _registerDataConnection(connection, remoteID) {
      this.connections.set(remoteID, connection);
    }

    /**
     * Connect to a remote peer
     * @param {string} remoteID - Remote Mesh ID
     * @returns {Promise<SharedDataChannel>} Promise that resolves with the data channel
     */
  }, {
    key: "openDataConnection",
    value: function openDataConnection(remoteID) {
      var _this3 = this;
      if (!this.peer) throw new Error('Peer not initialized');
      if (!remoteID || remoteID === '') {
        return Promise.reject(new Error('Remote ID not set'));
      }
      var conn = this.connections.get(remoteID);
      if (conn && conn.open) {
        return Promise.resolve(conn);
      }
      var newConnection = this.peer.connect(encodeToPeerID(remoteID));
      return new Promise(function (resolve, reject) {
        newConnection.on('open', function () {
          var _onSyncRequest = function onSyncRequest(data) {
            if (data.type === 'control' && data.command === 'syncRequest') {
              data.vars.forEach(function (_ref4) {
                var _ref5 = _slicedToArray(_ref4, 2),
                  key = _ref5[0],
                  value = _ref5[1];
                _this3.setSharedVar(key, value);
              });
              var syncAnswer = {
                sender: _this3.id,
                time: Date.now(),
                type: 'control',
                command: 'syncAnswer',
                vars: Array.from(_this3.sharedVars)
              };
              newConnection.send(syncAnswer);
              newConnection.off('data', _onSyncRequest);
              _this3._setupDataConnection(newConnection, remoteID);
              _this3._registerDataConnection(newConnection, remoteID);
              _this3.eventListeners.forEach(function (listener) {
                listener({
                  type: 'dataConnectionOpened',
                  data: remoteID
                });
              });
              resolve(newConnection);
            }
          };
          newConnection.on('data', _onSyncRequest);
        });
        newConnection.on('error', function (err) {
          reject(err);
        });
      });
    }

    /**
     * Get an existing data connection
     * @param {string} remoteID - Remote Mesh ID
     * @returns {DataConnection|undefined} Data connection if it exists
     */
  }, {
    key: "getDataConnection",
    value: function getDataConnection(remoteID) {
      return this.connections.get(remoteID);
    }

    /**
     * Check if a data connection is open
     * @param {string} remoteID - Remote Mesh ID
     * @returns {boolean} True if the data channel is open
     */
  }, {
    key: "isDataConnectionOpen",
    value: function isDataConnectionOpen(remoteID) {
      var connection = this.connections.get(remoteID);
      return !!connection && connection.open;
    }

    /**
     * Disconnect and remove a data connection
     * @param {string} remoteID - Remote peer ID
     */
  }, {
    key: "closeDataConnection",
    value: function closeDataConnection(remoteID) {
      var conn = this.connections.get(remoteID);
      if (conn) {
        if (conn.open) {
          conn.close();
        }
      }
    }

    /**
     * Get the ID of the data connection at a given index
     * @param {number} index - Connection index
     * @returns {string} Data connection Mesh ID
     */
  }, {
    key: "dataConnectionIDAt",
    value: function dataConnectionIDAt(index) {
      return Array.from(this.connections.keys())[index];
    }

    /**
     * Get the number of data connections
     * @returns {number} Number of data connections
     */
  }, {
    key: "dataConnectionCount",
    value: function dataConnectionCount() {
      return this.connections.size;
    }
  }, {
    key: "sendSyncRequest",
    value: function sendSyncRequest() {
      var data = {
        sender: this.id,
        time: Date.now(),
        type: 'control',
        command: 'syncRequest',
        vars: Object.fromEntries(this.sharedVars)
      };
      var _iterator2 = _createForOfIteratorHelper(this.connections.values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var connection = _step2.value;
          connection.send(data);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    /**
     * Get shared variable
     * @param {string} key - Variable name
     * @returns {any} Variable value
     */
  }, {
    key: "sharedVar",
    value: function sharedVar(key) {
      return this.sharedVars.get(key);
    }

    /**
     * Set shared variable
     * @param {string} key - Variable name
     * @param {any} value - Variable value
     */
  }, {
    key: "setSharedVar",
    value: function setSharedVar(key, value) {
      var data = {
        sender: this.id,
        time: Date.now(),
        type: 'var',
        key: key,
        value: value
      };
      var _iterator3 = _createForOfIteratorHelper(this.connections.values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var connection = _step3.value;
          connection.send(data);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      this.sharedVars.set(key, value);
    }

    /**
     * Get first shared event of the buffer
     * @returns {object|undefined} Shared event object
     */
  }, {
    key: "nextSharedEvent",
    value: function nextSharedEvent() {
      if (this.sharedEventBuffer.length <= this.sharedEventIndex) return;
      var event = this.sharedEventBuffer[this.sharedEventIndex];
      this.sharedEventIndex++;
      return event;
    }

    /**
     * Handle incoming shared events
     * @param {object} event - Shared event object
     */
  }, {
    key: "onSharedEvent",
    value: function onSharedEvent(event) {
      this.sharedEventBuffer.push(event);
      if (this.sharedEventBuffer.length > this.sharedEventBufferLength) {
        this.sharedEventBuffer.shift();
        this.sharedEventIndex--;
        if (this.sharedEventIndex < 0) {
          this.sharedEventIndex = 0;
        }
      }
    }

    /**
     * Dispatch a shared event
     * @param {string} type - Event type
     * @param {any} data - Event data
     */
  }, {
    key: "dispatchSharedEvent",
    value: function dispatchSharedEvent(type, data) {
      var event = {
        sender: this.id,
        time: Date.now(),
        type: 'event',
        eventType: type,
        eventData: data
      };
      var _iterator4 = _createForOfIteratorHelper(this.connections.values()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var connection = _step4.value;
          connection.send(event);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      this.onSharedEvent(event);
    }
  }]);
}();

/**
 * Formatter which is used for translation.
 * This will be replaced which is used in the runtime.
 * @param {object} messageData - format-message object
 * @returns {string} - message for the locale
 */
var formatMessage = function formatMessage(messageData) {
  return messageData.default;
};

/**
 * Setup format-message for this extension.
 */
var setupTranslations = function setupTranslations() {
  var localeSetup = formatMessage.setup();
  if (localeSetup && localeSetup.translations[localeSetup.locale]) {
    Object.assign(localeSetup.translations[localeSetup.locale], translations[localeSetup.locale]);
  }
};
var EXTENSION_ID = 'xcxMesh';

/**
 * URL to get this extension as a module.
 * When it was loaded as a module, 'extensionURL' will be replaced a URL which is retrieved from.
 * @type {string}
 */
var extensionURL = 'https://yokobond.github.io/xcx-mesh/dist/xcxMesh.mjs';

/**
 * Class for the extension blocks.
 */
var MeshBlocks = /*#__PURE__*/function () {
  /**
   * Construct a set of blocks for Mesh.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */
  function MeshBlocks(runtime) {
    _classCallCheck$1(this, MeshBlocks);
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime;
    if (runtime.formatMessage) {
      // Replace 'formatMessage' to a formatter which is used in the runtime.
      formatMessage = runtime.formatMessage;
    }

    /**
     * The peer connection manager.
     * @type {Mesh}
     */
    this.mesh = new Mesh();
    this.mesh.addMeshEventListener(this.onMeshEvent.bind(this));

    /** @type {object} the current processing event */
    this.processingSharedEvent = null;
    /** @type {number} the interval for polling the shared event */
    this.sharedEventPollingInterval = 10;
    /** @type {number} the interval for checking the completion of the shared event */
    this.eventCompletionCheckInterval = 10;
    this.startSharedEventProcessing();
  }

  /**
   * Handle the mesh event.
   * @param {object} event - the mesh event.
   */
  return _createClass$1(MeshBlocks, [{
    key: "onMeshEvent",
    value: function onMeshEvent(event) {
      if (event.type === 'dataConnectionRequested') {
        this.runtime.startHats('xcxMesh_whenDataConnectionRequested');
      }
    }

    /**
     * Open the peer with ID.
     * If the peer is already signaling with the same ID, it will not reconnect.
     * If the peer is already signaling with a different ID, it will disconnect and reconnect.
     * @param {object} args - the block's arguments.
     * @param {object} util - utility object provided by the runtime.
     * @param {string} args.ID - local ID.
     * @returns {Promise<string>} - a promise which resolves after signaling the peer.
     * @throws {Error} - Thrown if the peer is already signaling with the same signal name.
     * @throws {Error} - Thrown if the peer is already disconnected.
     */
  }, {
    key: "openPeer",
    value: (function () {
      var _openPeer = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(args, util) {
        var localID;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.isPeerOpening) {
                _context.next = 3;
                break;
              }
              util.yield();
              return _context.abrupt("return");
            case 3:
              this.isPeerOpening = true;
              localID = String(args.ID).trim();
              _context.prev = 5;
              _context.next = 8;
              return this.mesh.openPeer(localID);
            case 8:
              return _context.abrupt("return", "Open as \"".concat(this.mesh.id, "\""));
            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](5);
              return _context.abrupt("return", "Failed to open as \"".concat(localID, "\": ").concat(_context.t0));
            case 14:
              _context.prev = 14;
              this.isPeerOpening = false;
              return _context.finish(14);
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[5, 11, 14, 17]]);
      }));
      function openPeer(_x, _x2) {
        return _openPeer.apply(this, arguments);
      }
      return openPeer;
    }()
    /**
     * Check if the peer is open.
     * @returns {boolean} - true if the peer is open.
     */
    )
  }, {
    key: "isPeerOpen",
    value: function isPeerOpen() {
      return this.mesh.isPeerOpen();
    }

    /**
     * Close the peer.
     */
  }, {
    key: "closePeer",
    value: function closePeer() {
      this.mesh.closePeer();
    }

    /**
     * Return the ID of the local peer.
     * @returns {string} - the ID of the local peer.
     */
  }, {
    key: "myID",
    value: function myID() {
      return this.mesh.id || '';
    }

    /**
     * Set ICE servers.
     * @param {object} args - arguments for the block.
     * @param {string} args.SERVERS - the ICE servers.
     * @return {string} - the result of setting the ICE servers.
     */
  }, {
    key: "setICEServers",
    value: function setICEServers(args) {
      var servers = String(args.SERVERS).trim();
      try {
        this.mesh.setICEServers(servers);
        return "ICE servers set to \"".concat(servers, "\"");
      } catch (e) {
        return "Failed to set ICE servers: ".concat(e);
      }
    }

    /**
     * Set PeerJS server.
     * @param {object} args - arguments for the block.
     * @param {string} args.SERVER - the server URL.
     * @returns {string} - result message
     */
  }, {
    key: "setPeerServer",
    value: function setPeerServer(args) {
      var server = String(args.SERVER).trim();
      try {
        this.mesh.setPeerServer(server);
        return "PeerJS server set to \"".concat(server, "\"");
      } catch (e) {
        return "Failed to set PeerJS server: ".concat(e);
      }
    }

    /**
     * Open data connection with a remote peer.
     * @param {object} args - the block's arguments.
     * @param {string} args.ID - the remote ID.
     * @returns {string} - the result of connecting to the peer.
     */
  }, {
    key: "openDataConnection",
    value: (function () {
      var _openDataConnection = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(args) {
        var remoteID;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              remoteID = String(args.ID).trim();
              _context2.prev = 1;
              _context2.next = 4;
              return this.mesh.openDataConnection(remoteID);
            case 4:
              return _context2.abrupt("return", "Connected to peer ".concat(remoteID));
            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2["catch"](1);
              return _context2.abrupt("return", "Failed to connect to peer ".concat(remoteID, ": ").concat(_context2.t0));
            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[1, 7]]);
      }));
      function openDataConnection(_x3) {
        return _openDataConnection.apply(this, arguments);
      }
      return openDataConnection;
    }()
    /**
     * Check if the data connection is open.
     * @param {object} args - the block's arguments.
     * @param {string} args.ID - the remote ID.
     * @returns {boolean} - true if the data channel is open.
     */
    )
  }, {
    key: "isDataConnectionOpen",
    value: function isDataConnectionOpen(args) {
      var remoteID = String(args.ID).trim();
      return this.mesh.isDataConnectionOpen(remoteID);
    }

    /**
     * Close the data connection of the remote peer.
     * @param {object} args - the block's arguments.
     * @param {string} args.ID - the remote ID.
     * @returns {Promise<void>} - a promise which resolves after disconnecting the peer.
     */
  }, {
    key: "closeDataConnection",
    value: (function () {
      var _closeDataConnection = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(args) {
        var remoteID;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              remoteID = String(args.ID).trim();
              _context3.next = 3;
              return this.mesh.closeDataConnection(remoteID);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function closeDataConnection(_x4) {
        return _closeDataConnection.apply(this, arguments);
      }
      return closeDataConnection;
    }()
    /**
     * Return the data connection ID at the index.
     * @param {object} args - arguments for the block.
     * @param {number} args.CONNECTION_INDEX - the index of the data connection.
     * @return {string} - the data connection ID.
     */
    )
  }, {
    key: "dataConnectionIDAt",
    value: function dataConnectionIDAt(args) {
      var index = Cast$1.toNumber(args.CONNECTION_INDEX) - 1;
      var remoteID = this.mesh.dataConnectionIDAt(index);
      return remoteID ? remoteID : '';
    }

    /**
     * Return the number of data channels.
     * @returns {number} - the number of data channels.
     */
  }, {
    key: "dataConnectionCount",
    value: function dataConnectionCount() {
      return this.mesh.dataConnectionCount();
    }

    /**
     * Return the value of the key.
     * @param {object} args - arguments for the block.
     * @param {string} args.KEY - the key.
     * @return {string} - the value of the key.
     */
  }, {
    key: "sharedVar",
    value: function sharedVar(args) {
      var key = String(args.KEY).trim();
      return this.mesh.sharedVar(key) || '';
    }

    /**
     * Set the value of the key.
     * @param {object} args - arguments for the block.
     * @param {string} args.KEY - the key.
     * @param {string} args.VALUE - the value.
     * @param {object} util - utility object provided by the runtime.
     * @return {string} - the result of setting the value.
     */
  }, {
    key: "setSharedVar",
    value: function setSharedVar(args) {
      var key = String(args.KEY).trim();
      var value = Cast$1.toString(args.VALUE);
      try {
        this.mesh.setSharedVar(key, value);
      } catch (e) {
        return "Failed to set \"".concat(key, "\" to \"").concat(value, "\": ").concat(e);
      }
      return "Set \"".concat(key, "\" to \"").concat(value, "\"");
    }

    /**
     * Return the last event type.
     * @return {string} - the last event type.
     */
  }, {
    key: "lastSharedEventType",
    value: function lastSharedEventType() {
      var event = this.processingSharedEvent;
      return event && event.eventType || '';
    }

    /**
     * Return the last event data.
     * @return {string} - the last event data.
     */
  }, {
    key: "lastSharedEventData",
    value: function lastSharedEventData() {
      var event = this.processingSharedEvent;
      return event && event.eventData || '';
    }

    /**
     * Send the event.
     * @param {object} args - arguments for the block.
     * @param {string} args.TYPE - the event type.
     * @param {string} args.DATA - the event data.
     * @return {Promise<string>} - resolve with the result of sending the event.
     */
  }, {
    key: "dispatchSharedEvent",
    value: function dispatchSharedEvent(args) {
      var type = String(args.TYPE).trim();
      var data = Cast$1.toString(args.DATA);
      try {
        this.mesh.dispatchSharedEvent(type, data);
      } catch (e) {
        return "Failed to dispatch event \"".concat(type, "\": ").concat(e);
      }
    }

    /**
     * Handle the shared event.
     */
  }, {
    key: "onSharedEvent",
    value: function onSharedEvent() {
      this.runtime.startHats('xcxMesh_whenSharedEventReceived');
    }

    /**
     * Start the shared event processing.
     * This is called when the project is started.
     * This gets a next event from the mesh and process it then repeat.
     * This is called only once.
     */
  }, {
    key: "startSharedEventProcessing",
    value: function startSharedEventProcessing() {
      var _this = this;
      var blocks = this;
      var _nextEvent = function nextEvent() {
        var event = blocks.mesh.nextSharedEvent();
        if (event) {
          _this.processingSharedEvent = event;
          blocks.processSharedEvent(event, _nextEvent);
        } else {
          setTimeout(_nextEvent, _this.sharedEventPollingInterval);
        }
      };
      setTimeout(_nextEvent, 0);
    }

    /**
     * Process the shared event with the callback.
     * The callback will be called after the all started threads are finished.
     * @param {object} event - the shared event.
     * @param {Function} onCompletion - the callback function.
     */
  }, {
    key: "processSharedEvent",
    value: function processSharedEvent(event, onCompletion) {
      var _this2 = this;
      // Have we run before, starting threads?
      if (!event.startedThreads) {
        // No - start hats for this broadcast.
        event.startedThreads = this.runtime.startHats('xcxMesh_whenSharedEventReceived');
        if (event.startedThreads.length === 0) {
          // Nothing was started.
          return;
        }
      }
      // We've run before; check if the wait is still going on.
      var waiting = event.startedThreads.some(function (thread) {
        return _this2.runtime.threads.indexOf(thread) !== -1;
      });
      if (waiting) {
        setTimeout(function () {
          _this2.processSharedEvent(event, onCompletion);
        }, this.eventCompletionCheckInterval);
      } else {
        onCompletion();
      }
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */
  }, {
    key: "getInfo",
    value: function getInfo() {
      setupTranslations();
      return {
        id: MeshBlocks.EXTENSION_ID,
        name: MeshBlocks.EXTENSION_NAME,
        extensionURL: MeshBlocks.extensionURL,
        blockIconURI: img,
        showStatusButton: false,
        blocks: [{
          opcode: 'openPeer',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxMesh.openPeer',
            default: 'open peer [ID]'
          }),
          arguments: {
            ID: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.openPeer.defaultID',
                default: 'myID'
              })
            }
          }
        }, {
          opcode: 'myID',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          text: formatMessage({
            id: 'xcxMesh.myID',
            default: 'my ID'
          })
        }, {
          opcode: 'isPeerOpen',
          blockType: BlockType$1.BOOLEAN,
          text: formatMessage({
            id: 'xcxMesh.isPeerOpen',
            default: 'peer is open'
          })
        }, {
          opcode: 'closePeer',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxMesh.closePeer',
            default: 'close peer'
          })
        }, {
          opcode: 'setPeerServer',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxMesh.setPeerServer',
            default: 'set peer server to [SERVER]'
          }),
          arguments: {
            SERVER: {
              type: ArgumentType$1.STRING,
              defaultValue: 'https://0.peerjs.com'
            }
          }
        }, {
          opcode: 'setICEServers',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxMesh.setICEServers',
            default: 'set ICE servers to [SERVERS]'
          }),
          arguments: {
            SERVERS: {
              type: ArgumentType$1.STRING,
              defaultValue: ' '
            }
          }
        }, '---', {
          opcode: 'openDataConnection',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxMesh.openDataConnection',
            default: 'open connection to [ID]'
          }),
          arguments: {
            ID: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.openDataConnection.defaultID',
                default: 'remoteID'
              })
            }
          }
        }, {
          opcode: 'isDataConnectionOpen',
          blockType: BlockType$1.BOOLEAN,
          text: formatMessage({
            id: 'xcxMesh.isDataConnectionOpen',
            default: 'connection to [ID] is open'
          }),
          arguments: {
            ID: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.isDataConnectionOpen.defaultID',
                default: 'remoteID'
              })
            }
          }
        }, {
          opcode: 'closeDataConnection',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxMesh.closeDataConnection',
            default: 'close connection to [ID]'
          }),
          arguments: {
            ID: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.closeDataConnection.defaultID',
                default: 'remoteID'
              })
            }
          }
        }, {
          opcode: 'whenDataConnectionRequested',
          blockType: BlockType$1.EVENT,
          isEdgeActivated: false,
          text: formatMessage({
            id: 'xcxMesh.whenDataConnectionRequested',
            default: 'when connection requested'
          })
        }, {
          opcode: 'dataConnectionIDAt',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          text: formatMessage({
            id: 'xcxMesh.dataConnectionIDAt',
            default: 'connection ID at [CONNECTION_INDEX]'
          }),
          arguments: {
            CONNECTION_INDEX: {
              type: ArgumentType$1.NUMBER,
              defaultValue: 1
            }
          }
        }, {
          opcode: 'dataConnectionCount',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          text: formatMessage({
            id: 'xcxMesh.dataConnectionCount',
            default: 'connection count'
          })
        }, '---', {
          opcode: 'setSharedVar',
          blockType: BlockType$1.COMMAND,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxMesh.setSharedVar',
            default: 'set value of [KEY] to [VALUE]'
          }),
          arguments: {
            KEY: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.setSharedVar.defaultKey',
                default: 'key'
              })
            },
            VALUE: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.setSharedVar.defaultValue',
                default: 'value'
              })
            }
          }
        }, {
          opcode: 'sharedVar',
          blockType: BlockType$1.REPORTER,
          blockAllThreads: false,
          text: formatMessage({
            id: 'xcxMesh.sharedVar',
            default: 'value of [KEY]'
          }),
          arguments: {
            KEY: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.sharedVar.defaultKey',
                default: 'key'
              })
            }
          }
        }, '---', {
          opcode: 'dispatchSharedEvent',
          blockType: BlockType$1.COMMAND,
          text: formatMessage({
            id: 'xcxMesh.dispatchSharedEvent',
            default: 'dispatch event [TYPE] with [DATA]'
          }),
          arguments: {
            TYPE: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.dispatchSharedEvent.defaultEvent',
                default: 'event'
              })
            },
            DATA: {
              type: ArgumentType$1.STRING,
              defaultValue: formatMessage({
                id: 'xcxMesh.dispatchSharedEvent.defaultData',
                default: 'data'
              })
            }
          }
        }, {
          opcode: 'whenSharedEventReceived',
          blockType: BlockType$1.EVENT,
          isEdgeActivated: false,
          shouldRestartExistingThreads: true,
          text: formatMessage({
            id: 'xcxMesh.whenSharedEventReceived',
            default: 'when event received'
          })
        }, {
          opcode: 'lastSharedEventType',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          text: formatMessage({
            id: 'xcxMesh.lastSharedEventType',
            default: 'event type'
          }),
          arguments: {}
        }, {
          opcode: 'lastSharedEventData',
          blockType: BlockType$1.REPORTER,
          disableMonitor: true,
          text: formatMessage({
            id: 'xcxMesh.lastSharedEventData',
            default: 'event data'
          }),
          arguments: {}
        }],
        menus: {}
      };
    }
  }], [{
    key: "formatMessage",
    set:
    /**
     * A translation object which is used in this class.
     * @param {FormatObject} formatter - translation object
     */
    function set(formatter) {
      formatMessage = formatter;
      if (formatMessage) setupTranslations();
    }

    /**
     * @return {string} - the name of this extension.
     */
  }, {
    key: "EXTENSION_NAME",
    get: function get() {
      return formatMessage({
        id: 'xcxMesh.name',
        default: 'Mesh',
        description: 'name of the extension'
      });
    }

    /**
     * @return {string} - the ID of this extension.
     */
  }, {
    key: "EXTENSION_ID",
    get: function get() {
      return EXTENSION_ID;
    }

    /**
     * URL to get this extension.
     * @type {string}
     */
  }, {
    key: "extensionURL",
    get: function get() {
      return extensionURL;
    }

    /**
     * Set URL to get this extension.
     * The extensionURL will be changed to the URL of the loading server.
     * @param {string} url - URL
     */,
    set: function set(url) {
      extensionURL = url;
    }
  }]);
}();

export { MeshBlocks as blockClass, entry };
//# sourceMappingURL=xcxMesh.mjs.map
